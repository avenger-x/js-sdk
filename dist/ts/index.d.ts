import BN from 'bn.js';
import SDKClient from './common/SDKClient';
import TronSDKClient from './common/TronSDKClient';
import { Utils } from './common/Utils';
import DepositManager from './root/DepositManager';
import Registry from './root/Registry';
import RootChain from './root/RootChain';
import WithdrawManager from './root/WithdrawManager';
import { address, MaticClientInitializationOptions, order, SendOptions, burnErc20Options, burnErc721Options } from './types/Common';
import { mapPromise } from './common/MapPromise';
export declare class BttcPOSClient extends SDKClient {
    private rootChain;
    private posRootChainManager;
    constructor(options?: any);
    approveERC20ForDeposit(rootToken: address, amount: BN | string, options?: SendOptions): Promise<any>;
    approveMaxERC20ForDeposit(rootToken: address, options?: SendOptions): Promise<any>;
    getERC20Allowance(userAddress: address, token: address, options?: SendOptions): Promise<any>;
    depositERC20ForUser(rootToken: address, user: address, amount: BN | string, options?: SendOptions): Promise<any>;
    depositEtherForUser(user: address, amount: BN | string, options?: SendOptions): Promise<any>;
    burnERC20(option: burnErc20Options, options?: SendOptions): Promise<any>;
    exitERC20(txHash: string, options?: SendOptions): Promise<any>;
    isERC20ExitProcessed(txHash: string): Promise<any>;
    approveERC721ForDeposit(rootToken: address, tokenId: BN | string, options?: SendOptions): Promise<any>;
    isApprovedERC721ForDeposit(rootToken: address, tokenId: BN | string, options?: SendOptions): Promise<boolean>;
    approveAllERC721ForDeposit(rootToken: address, options?: SendOptions): Promise<any>;
    isApprovedAllERC721ForDeposit(rootToken: address, userAddress: address, options?: SendOptions): Promise<any>;
    depositERC721ForUser(rootToken: address, user: address, tokenId: BN | string, options?: SendOptions): Promise<any>;
    depositBatchERC721ForUser(rootToken: address, user: address, tokenIds: (BN | string)[], options?: SendOptions): Promise<any>;
    burnERC721(opt: burnErc721Options, options?: SendOptions): Promise<any>;
    burnBatchERC721(childToken: address, tokenIds: (BN | string)[], options?: SendOptions): Promise<any>;
    exitERC721(txHash: string, options?: SendOptions): Promise<any>;
    exitBatchERC721(txHash: string, options?: SendOptions): Promise<any>;
    exitERC721WithMetadata(txHash: string, options?: SendOptions): Promise<any>;
    isERC721ExitProcessed(txHash: string): Promise<any>;
    isBatchERC721ExitProcessed(txHash: string): Promise<any>;
    approveERC1155ForDeposit(rootToken: address, options?: SendOptions): Promise<any>;
    approveMintableERC1155ForDeposit(rootToken: address, options?: SendOptions): Promise<any>;
    depositSingleERC1155ForUser(rootToken: address, user: address, tokenId: BN | string, amount: BN | string, data?: string, options?: SendOptions): Promise<any>;
    depositBatchERC1155ForUser(rootToken: address, user: address, tokenIds: (BN | string)[], amounts: (BN | string)[], data?: string, options?: SendOptions): Promise<any>;
    burnSingleERC1155(childToken: address, tokenId: BN | string, amount: BN | string, options?: SendOptions): Promise<any>;
    burnBatchERC1155(childToken: address, tokenIds: (BN | string)[], amounts: (BN | string)[], options?: SendOptions): Promise<any>;
    exitSingleERC1155(txHash: string, options?: SendOptions): Promise<any>;
    isSingleERC1155ExitProcessed(txHash: string): Promise<any>;
    exitBatchERC1155(txHash: string, options?: SendOptions): Promise<any>;
    isBatchERC1155ExitProcessed(txHash: string): Promise<any>;
}
export declare class TronWebClient extends TronSDKClient {
    private rootChain;
    private posRootChainManager;
    private tronWebClientOptions;
    constructor(options?: any);
    approveERC20ForDeposit(rootToken: address, amount: BN | string, options?: SendOptions): Promise<any>;
    approveMaxERC20ForDeposit(rootToken: address, options?: SendOptions): Promise<any>;
    getERC20Allowance(userAddress: address, token: address, options?: SendOptions): Promise<any>;
    depositERC20ForUser(rootToken: address, user: address, amount: BN | string, options?: SendOptions): Promise<any>;
    depositEtherForUser(user: address, amount: BN | string, options?: SendOptions): Promise<any>;
    burnERC20(option: burnErc20Options, options?: SendOptions): Promise<any>;
    exitERC20(txHash: string, options?: SendOptions): Promise<any>;
    isERC20ExitProcessed(txHash: string): Promise<any>;
    approveERC721ForDeposit(rootToken: address, tokenId: BN | string, options?: SendOptions): Promise<any>;
    isApprovedERC721ForDeposit(rootToken: address, tokenId: BN | string, options?: SendOptions): Promise<boolean>;
    approveAllERC721ForDeposit(rootToken: address, options?: SendOptions): Promise<any>;
    isApprovedAllERC721ForDeposit(rootToken: address, userAddress: address, options?: SendOptions): Promise<any>;
    depositERC721ForUser(rootToken: address, user: address, tokenId: BN | string, options?: SendOptions): Promise<any>;
    depositBatchERC721ForUser(rootToken: address, user: address, tokenIds: (BN | string)[], options?: SendOptions): Promise<any>;
    burnERC721(opt: burnErc721Options, options?: SendOptions): Promise<any>;
    burnBatchERC721(childToken: address, tokenIds: (BN | string)[], options?: SendOptions): Promise<any>;
    exitERC721(txHash: string, options?: SendOptions): Promise<any>;
    exitBatchERC721(txHash: string, options?: SendOptions): Promise<any>;
    exitERC721WithMetadata(txHash: string, options?: SendOptions): Promise<any>;
    isERC721ExitProcessed(txHash: string): Promise<any>;
    isBatchERC721ExitProcessed(txHash: string): Promise<any>;
    approveERC1155ForDeposit(rootToken: address, options?: SendOptions): Promise<any>;
    approveMintableERC1155ForDeposit(rootToken: address, options?: SendOptions): Promise<any>;
    depositSingleERC1155ForUser(rootToken: address, user: address, tokenId: BN | string, amount: BN | string, data?: string, options?: SendOptions): Promise<any>;
    depositBatchERC1155ForUser(rootToken: address, user: address, tokenIds: (BN | string)[], amounts: (BN | string)[], data?: string, options?: SendOptions): Promise<any>;
    burnSingleERC1155(childToken: address, tokenId: BN | string, amount: BN | string, options?: SendOptions): Promise<any>;
    burnBatchERC1155(childToken: address, tokenIds: (BN | string)[], amounts: (BN | string)[], options?: SendOptions): Promise<any>;
    exitSingleERC1155(txHash: string, options?: SendOptions): Promise<any>;
    isSingleERC1155ExitProcessed(txHash: string): Promise<any>;
    exitBatchERC1155(txHash: string, options?: SendOptions): Promise<any>;
    isBatchERC1155ExitProcessed(txHash: string): Promise<any>;
}
export default class Bttc extends SDKClient {
    depositManager: DepositManager;
    rootChain: RootChain;
    withdrawManager: WithdrawManager;
    registry: Registry;
    utils: Utils;
    static BttcPOSClient: typeof BttcPOSClient;
    static TronWebClient: typeof TronWebClient;
    static mapPromise: typeof mapPromise;
    constructor(options?: MaticClientInitializationOptions);
    initialize(): Promise<[void, void]>;
    transferEther(to: address, amount: BN | string, options?: SendOptions): Promise<any>;
    depositEther(amount: BN | string, options?: SendOptions): Promise<any>;
    depositStatusFromTxHash(txHash: string): Promise<{
        receipt: any;
        deposits: any[];
    }>;
    approveERC20TokensForDeposit(token: address, amount: BN | string, options?: SendOptions): Promise<any>;
    approveMaxERC20TokensForDeposit(token: address, options?: SendOptions): Promise<any>;
    getERC20Allowance(userAddress: address, token: address, options?: SendOptions): Promise<any>;
    getTransferSignature(sellOrder: order, buyOrder: order, options: SendOptions): Promise<any>;
    transferWithSignature(sig: string, sellOrder: order, buyOrder: order, to: address, options: SendOptions): Promise<any>;
    depositERC20ForUser(token: address, user: address, amount: BN | string, options?: SendOptions): Promise<any>;
    safeDepositERC721Tokens(token: address, tokenId: BN, options?: SendOptions): Promise<any>;
    startWithdraw(token: address, amount: BN | string, options?: SendOptions): Promise<any>;
    startWithdrawForNFT(token: address, tokenId: BN | string, options?: SendOptions): Promise<any>;
    withdraw(txHash: string, options?: SendOptions): Promise<any>;
    withdrawNFT(txHash: string, options?: SendOptions): Promise<any>;
    processExits(tokenAddress: string | string[], options?: SendOptions): Promise<any>;
    private _validateInputs;
}
